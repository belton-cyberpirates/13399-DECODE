//f-f-f-f-f-f-f-f-five nights at bear5s
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⠤⠀⢀⣤⣤⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⢠⠤⠟⢂⢘⡿⣿⣧⣄⡀⠀⠀⢀⠄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⠠⠌⠐⠀⠈⠀⢀⣒⠲⣿⡿⢂⣂⠠⣾⠶⠈⠀⠤⣀⠔⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣔⠦⠘⠛⠃⠈⣁⠘⠛⠁⢿⢿⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠎⣾⣷⣿⣿⣿⣶⣶⣿⣿⣿⣿⣮⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⡀⠀⠉⠉⠉⠙⠛⠙⠛⣛⢉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⣀⣀⣠⣴⣶⣾⣿⣿⣇⠀⠑⠂⠀⠀⠀⠀⠀⠀⠐⣀⠀⠘⠉⠁⢠⣤⣤⣀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⢃⣿⣽⣿⠁⣠⣴⣾⣿⣾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠈⠽⣿⣿⣷⣆⠀⠀⠀⠀
//⠀⠀⠀⠄⠈⠁⠀⠀⠀⢠⣉⠉⠩⠭⠐⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠉⠁⣀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠒⠚⠿⠭⢭⡅⠀⢀⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⢲⣟⣿⣿⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠛⠛⠛⠛⠛⡛⠛⠋⠀⠀⠀⠀⠀⠀⠀⠠⡶⠄⢀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠈⠺⠍⠐⠐⡒⠉⠀⠀⠀⠔⠂⢙⣶⣿⣽⣿⡆⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡐⣶⣶⣄⠀⠀⠀⠀⠀⠀⣠⣴⣶⣶⠀⠀⠀⠀⠀⠈⠁⠈⠉⠛⠁⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢤⣝⣿⣿⣿⠟⠀⠀⠀⠀⢻⢿⢻⣿⣿⠾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠈⢛⣻⣿⠁⠀⠀⠀⠀⠀⠀⠈⣚⣿⣯⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣨⣵⣿⣿⠀⠀⠀⠀⠀⠀⠠⢭⣤⣭⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢬⣹⢿⣿⡏⠀⠀⠀⠀⠀⠀⠐⡿⣿⣿⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠨⠍⠉⠀⠀⠀⠀⠀⠀⠀⠡⠔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⢠⡤⠀⢀⠀⣤⠄⢀⣠⣤⣄⠀⠀⠀⠀⢀⣤⣤⡀⠀⢀⣀⡄⠀⠤⣤⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀⠉⠉⠉⠁⠈⠉⠉⠉⠁⠀⠀⠀⠉⠉⠉⠁⠀⠉⠉⠉⠀⠀⠉⠉
// aaaaaaaahhh⠀⠀⠀⠀⠀
package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.hardware.gobilda.GoBildaPinpointDriver;
import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.util.ElapsedTime;

@TeleOp(name="Drive Code Payten")
@Disabled
public class DriveCodePayten extends LinearOpMode {
    //speeds
    final int FLYSPEED_CLOSE = 1200;
    final int FLYSPEED_MED = 1560;
    final int FLYSPEED_FAR = 1920;
    final int SPEED_TOLERANCE = 200;
    //static final double turretSpeed = .5;
    int driveSpeed = 700;
    double boost = .5;
    double flyWheelSpeed;
    //outtake motors
    private DcMotorEx turret;
    private DcMotorEx flyWheelRight;
    private DcMotorEx flyWheelLeft;
    //intake
    private DcMotorEx intake;
    //servos
    private CRServo outZero;
    private CRServo outOne;
    //drivemotors
    private DcMotorEx driveMotorBL;
    private DcMotorEx driveMotorFL;
    private DcMotorEx driveMotorBR;
    private DcMotorEx driveMotorFR;

    private DriveMotors driveMotors;
    
    double readMotor;
    double headingOffset = 0;

    @Override
    public void runOpMode() {
        
        intake = hardwareMap.get(DcMotorEx.class, "intake");
        outZero = hardwareMap.get(CRServo.class, "out0");
        outOne = hardwareMap.get(CRServo.class, "out1");
        flyWheelRight = hardwareMap.get(DcMotorEx.class, "fly1");
        flyWheelLeft = hardwareMap.get(DcMotorEx.class, "fly2");
        turret = hardwareMap.get(DcMotorEx.class, "turret");
        driveMotorBL = hardwareMap.get(DcMotorEx.class, "driveBL");
        driveMotorFL = hardwareMap.get(DcMotorEx.class, "driveFL");
        driveMotorBR = hardwareMap.get(DcMotorEx.class, "driveBR");
        driveMotorFR = hardwareMap.get(DcMotorEx.class, "driveFR");
        
        driveMotors = new DriveMotors(this);
        
        telemetry.addData("Status", "Initialized");
        telemetry.update();
        
        driveMotorBL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        driveMotorBR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        driveMotorFL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        driveMotorFR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        
        turret.setTargetPosition(0);
        turret.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        turret.setVelocity(500);
        
        waitForStart();
        
        while (opModeIsActive()) {
            
            double twoLeftStickY = gamepad2.left_stick_y;
            double twoRightStickX = gamepad2.right_stick_x;
            
            readMotor = flyWheelRight.getVelocity();

            //drive
            if (gamepad1.y) {
                headingOffset = driveMotors.heading;
            }
            
            // P1 variables
            double leftStickXGP1 = gamepad1.left_stick_x;
            double leftStickYGP1 = gamepad1.left_stick_y;
            double rightStickXGP1 = gamepad1.right_stick_x;
            double rightStickYGP1 = gamepad1.right_stick_y;

            // Get the speed the bot would go with the joystick pushed all the way
            int maxSpeed = (int)calcMaxSpeed(/*gamepad1.right_trigger*/ - gamepad1.left_trigger, driveSpeed, boost); // Commented out boost, only slowdown
            
            double joystickLength = Math.sqrt( Math.pow(gamepad1.right_stick_y, 2) + Math.pow(gamepad1.right_stick_x, 2) );
            double joystickAngle = -Math.atan2(gamepad1.right_stick_y, gamepad1.right_stick_x) - Math.PI/2;
            
            double turnPower = -gamepad1.right_stick_x;

            // Virtually rotate the joystick by the angle of the robot
            double heading = driveMotors.heading - headingOffset;
            
            double rotatedX =
                leftStickXGP1 * Math.cos(heading) -
                leftStickYGP1 * Math.sin(heading);
            double rotatedY =
                leftStickXGP1 * Math.sin(heading) +
                leftStickYGP1 * Math.cos(heading);
            
            // strafing is slower than rolling, bump horizontal speed
            rotatedX *= Math.sqrt(2);
            
            // Set the power of the wheels based off the new joystick coordinates
            // y+x+stick <- [-1,1]
            driveMotorBL.setVelocity(maxSpeed * (rotatedX + rotatedY + turnPower));
            driveMotorFL.setVelocity(maxSpeed * (-rotatedX + rotatedY + turnPower));
            driveMotorBR.setVelocity(maxSpeed * (rotatedX - rotatedY + turnPower));
            driveMotorFR.setVelocity(maxSpeed * (-rotatedX - rotatedY + turnPower));
            
            //flywheel
            if (gamepad2.y){
                flyWheelSpeed = FLYSPEED_FAR;
            } else if (gamepad2.a){
                flyWheelSpeed = FLYSPEED_CLOSE;
            } else {
                flyWheelSpeed = FLYSPEED_MED;
            }
            
            if (gamepad2.right_bumper){
                flyWheelSpin(flyWheelSpeed, -1);
            } else {
                flyWheelSpin(flyWheelSpeed, 1);
            }
            //turret
            //turret.setPower(twoRightStickX * turretSpeed);
            
            //intake + servos
            if (gamepad2.left_trigger > 0) {
                intake.setPower(-1);
                outZero.setPower(1);
                outOne.setPower(-1);
            } else if (gamepad2.right_trigger > 0) {
                intake.setPower(-1);
                outZero.setPower(-1);
                outOne.setPower(1);
            } else if (gamepad2.left_bumper){
                intake.setPower(1);
                outZero.setPower(1);
                outOne.setPower(-1);
            } else {
                intake.setPower(0);
                outZero.setPower(0);
                outOne.setPower(0);
            }

            telemetry.addData("motor flywheel vel:", readMotor);
            telemetry.addData("target speed", readMotor);
            telemetry.update();
        }
    }


    private void flyWheelSpin(double speed, int direction){
        //direction is 1 or -1
        if (readMotor < speed - 200){
            flyWheelLeft.setPower(direction);
            flyWheelRight.setPower(-direction);
        } else if (readMotor > speed + 200){
            flyWheelLeft.setPower(direction * .5);
            flyWheelRight.setPower(-direction * .5);
        }
    }


    double calcMaxSpeed(double triggerVal, double BASE_SPEED, double MAX_BOOST) {
        double boostRatio = triggerVal * MAX_BOOST;
        double boostSpeed = boostRatio * BASE_SPEED;
        return BASE_SPEED + boostSpeed;
    }
}