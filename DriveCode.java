//f-f-f-f-f-f-f-f-five nights at bear5s
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⠤⠀⢀⣤⣤⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⢠⠤⠟⢂⢘⡿⣿⣧⣄⡀⠀⠀⢀⠄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⠠⠌⠐⠀⠈⠀⢀⣒⠲⣿⡿⢂⣂⠠⣾⠶⠈⠀⠤⣀⠔⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣔⠦⠘⠛⠃⠈⣁⠘⠛⠁⢿⢿⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠎⣾⣷⣿⣿⣿⣶⣶⣿⣿⣿⣿⣮⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⡀⠀⠉⠉⠉⠙⠛⠙⠛⣛⢉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⣀⣀⣠⣴⣶⣾⣿⣿⣇⠀⠑⠂⠀⠀⠀⠀⠀⠀⠐⣀⠀⠘⠉⠁⢠⣤⣤⣀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⢃⣿⣽⣿⠁⣠⣴⣾⣿⣾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠈⠽⣿⣿⣷⣆⠀⠀⠀⠀
//⠀⠀⠀⠄⠈⠁⠀⠀⠀⢠⣉⠉⠩⠭⠐⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠉⠁⣀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠒⠚⠿⠭⢭⡅⠀⢀⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⢲⣟⣿⣿⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠛⠛⠛⠛⠛⡛⠛⠋⠀⠀⠀⠀⠀⠀⠀⠠⡶⠄⢀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠈⠺⠍⠐⠐⡒⠉⠀⠀⠀⠔⠂⢙⣶⣿⣽⣿⡆⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡐⣶⣶⣄⠀⠀⠀⠀⠀⠀⣠⣴⣶⣶⠀⠀⠀⠀⠀⠈⠁⠈⠉⠛⠁⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢤⣝⣿⣿⣿⠟⠀⠀⠀⠀⢻⢿⢻⣿⣿⠾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠈⢛⣻⣿⠁⠀⠀⠀⠀⠀⠀⠈⣚⣿⣯⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣨⣵⣿⣿⠀⠀⠀⠀⠀⠀⠠⢭⣤⣭⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢬⣹⢿⣿⡏⠀⠀⠀⠀⠀⠀⠐⡿⣿⣿⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠨⠍⠉⠀⠀⠀⠀⠀⠀⠀⠡⠔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⢠⡤⠀⢀⠀⣤⠄⢀⣠⣤⣄⠀⠀⠀⠀⢀⣤⣤⡀⠀⢀⣀⡄⠀⠤⣤⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀⠉⠉⠉⠁⠈⠉⠉⠉⠁⠀⠀⠀⠉⠉⠉⠁⠀⠉⠉⠉⠀⠀⠉⠉
// aaaaaaaahhh⠀⠀⠀⠀⠀
package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;
import com.qualcomm.robotcore.hardware.LED;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.hardware.limelightvision.LLResult;
import com.qualcomm.hardware.limelightvision.LLResultTypes;
import com.qualcomm.hardware.limelightvision.LLStatus;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.hardware.LED;
import com.qualcomm.robotcore.hardware.DistanceSensor;

@TeleOp
public class DriveCode extends LinearOpMode {
    //flywheel constants
    final int FLYSPEED_CLOSE = 1200;
    final int FLYSPEED_MED = 1560;
    final int FLYSPEED_FAR = 2070;
    final int FLYSPEED_MIN = 1600;
    final double[] TAG_VALS =   {-0.5, -5,   -7,   -10}; //TODO find real values
    final int[] VELOCITY_VALS = {1500, 1750, 1900, 2000}; //TODO find real values

    //base constants
    final int driveSpeed = 1200;
    final int boostSpeed = 800;

    //intake
    private DcMotorEx intake;

    //servos
    private CRServo outZero;
    private CRServo outOne;
    private Servo stopper;

    //leds
    private LED led1green;
    private LED led2green;
    private LED led1red;
    private LED led2red;
    
    //sensors
    private DistanceSensor distance;
    
    //classes
    private DriveMotors driveMotors;
    //private Intake intake;
    private Launcher launcher;
    
    //variables
    double headingOffset = 0;
    int boost = 0;
    

    @Override
    public void runOpMode() {
        
        intake = hardwareMap.get(DcMotorEx.class, "intake");
        outZero = hardwareMap.get(CRServo.class, "out0");
        outOne = hardwareMap.get(CRServo.class, "out1");
        stopper = hardwareMap.get(Servo.class, "stopper");

        led1green = hardwareMap.get(LED.class, "led1green");
        led2green = hardwareMap.get(LED.class, "led2green");
        led1red = hardwareMap.get(LED.class, "led1red");
        led2red = hardwareMap.get(LED.class, "led2red");

        distance = hardwareMap.get(DistanceSensor.class, "distance");
        
        driveMotors = new DriveMotors(this);
        //intake = new Intake(this);
        launcher = new Launcher(this);
        
        telemetry.addData("Status", "Initialized");
        telemetry.update();
        
        waitForStart();
        
        while (opModeIsActive()) {
            
            if (gamepad1.y) {
                headingOffset = driveMotors.heading;
            }
            
            driveMotors.process();
            launcher.process();
            launcher.setTurretActive(gamepad2.a);

            //gamepad 1
            double oneRightStickX = - gamepad1.right_stick_x;
            double oneRightStickY = gamepad1.right_stick_y;
            double oneLeftStickX = gamepad1.left_stick_x;
            double oneLeftStickY = gamepad1.left_stick_y;

            //gamepad 2
            double twoLeftStickY = gamepad2.left_stick_y;
            double twoRightStickX = gamepad2.right_stick_x;
            
            //lights
            if (distance.getDistance(DistanceUnit.CM) < 5) {
                led1green.enable(false);
                led2green.enable(false);

                led2red.enable(true);
                led1red.enable(true);
            } 
            else {
                led2red.enable(false);
                led1red.enable(false);
            }
            
            //limelight
            LLResult result = launcher.limelight.getLatestResult();
            
            //flywheel
            double currentTagY = result.getTy(); // experiment with result.getTa()

            // find the tag vals that this value is between
            int lowerTagIndex = 0;
            int higherTagIndex = 0;
            for (int i = TAG_VALS.length-1; i >= 0; i--) {
                double tagY = TAG_VALS[i];

                if (tagY < currentTagY) {
                    lowerTagIndex = i;
                    higherTagIndex = i + 1;
                }
            }

            // find the ratio this value is between the tag vals
            double lowerTagVal = TAG_VALS[lowerTagIndex];
            double higherTagVal = TAG_VALS[higherTagIndex];

            double tagSliceLength = (higherTagVal - lowerTagVal);
            double tagSliceCoveredLength = (tagY - lowerTagVal);
            double interpMult = (tagSliceCoveredLength / tagSliceLength);

            // map the ratio to the matching velocity vals 
            int lowerVelocityVal = VELOCITY_VALS[lowerTagIndex];
            int higherVelocityVal = VELOCITY_VALS[higherTagIndex];

            int velocitySliceLength = (higherVelocityVal - lowerVelocityVal);
            int velocitySliceCoveredLength = (int)(interpMult * velocitySliceLength);

            // get target velocity
            int targetVelocity = lowerVelocityVal + velocitySliceCoveredLength;

            // double flyspeed = (result.getTy() * -58.77193) + 1050.24561;

            // if (flyspeed < FLYSPEED_MIN) {
            //     flyspeed = FLYSPEED_MIN;
            // }
            
            launcher.SetVelocity(targetVelocity);
            
            //boost
            boost = (int)((gamepad1.right_trigger - gamepad1.left_trigger) * boostSpeed);
            
            //drive
            if (gamepad1.a) {
                driveMotors.DriveFieldCentric(gamepad1.left_stick_x,
                    gamepad1.left_stick_y, 
                    gamepad1.right_stick_x, 
                    driveSpeed + boost,
                    headingOffset
                );
            }
            else {
                driveMotors.Drive(gamepad1.left_stick_x,
                    gamepad1.left_stick_y, 
                    gamepad1.right_stick_x, 
                    driveSpeed + boost
                );
            }
            
            //turret
            double tagSize = result.getTa();
            if (tagSize <= 0.6 && tagSize != 0) {
                launcher.setDistance(Distance.FAR);
            }
            else {
                launcher.setDistance(Distance.CLOSE);
            }
            
            //intake
            if (gamepad2.left_trigger > 0) {
                intake.setPower(-1);
                outZero.setPower(1);
                outOne.setPower(-1);
            } else if (gamepad2.right_trigger > 0) {
                intake.setPower(-1);
                outZero.setPower(-1);
                outOne.setPower(1);
                stopper.setPosition(BotConfig.STOPPER_OPEN_POS);
            } else if (gamepad2.left_bumper) {
                intake.setPower(1);
                outZero.setPower(1);
                outOne.setPower(-1);
            } else {
                intake.setPower(0);
                outZero.setPower(0);
                outOne.setPower(0);
                stopper.setPosition(BotConfig.STOPPER_CLOSE_POS);
            }

            telemetry.addData("tag size", result.getTa());
            telemetry.addData("tag x", result.getTx());
            telemetry.addData("tag y", result.getTy());
            telemetry.addData("flyspeed", flyspeed);
            telemetry.update();
        }
    }
}
