//f-f-f-f-f-f-f-f-five nights at bear5s
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⠤⠀⢀⣤⣤⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⢠⠤⠟⢂⢘⡿⣿⣧⣄⡀⠀⠀⢀⠄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⠠⠌⠐⠀⠈⠀⢀⣒⠲⣿⡿⢂⣂⠠⣾⠶⠈⠀⠤⣀⠔⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣔⠦⠘⠛⠃⠈⣁⠘⠛⠁⢿⢿⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠎⣾⣷⣿⣿⣿⣶⣶⣿⣿⣿⣿⣮⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⡀⠀⠉⠉⠉⠙⠛⠙⠛⣛⢉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⣀⣀⣠⣴⣶⣾⣿⣿⣇⠀⠑⠂⠀⠀⠀⠀⠀⠀⠐⣀⠀⠘⠉⠁⢠⣤⣤⣀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⢃⣿⣽⣿⠁⣠⣴⣾⣿⣾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠈⠽⣿⣿⣷⣆⠀⠀⠀⠀
//⠀⠀⠀⠄⠈⠁⠀⠀⠀⢠⣉⠉⠩⠭⠐⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠉⠁⣀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠒⠚⠿⠭⢭⡅⠀⢀⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⢲⣟⣿⣿⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠛⠛⠛⠛⠛⠛⠛⡛⠛⠋⠀⠀⠀⠀⠀⠀⠀⠠⡶⠄⢀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠈⠺⠍⠐⠐⡒⠉⠀⠀⠀⠔⠂⢙⣶⣿⣽⣿⡆⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡐⣶⣶⣄⠀⠀⠀⠀⠀⠀⣠⣴⣶⣶⠀⠀⠀⠀⠀⠈⠁⠈⠉⠛⠁⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢤⣝⣿⣿⣿⠟⠀⠀⠀⠀⢻⢿⢻⣿⣿⠾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠈⢛⣻⣿⠁⠀⠀⠀⠀⠀⠀⠈⣚⣿⣯⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣨⣵⣿⣿⠀⠀⠀⠀⠀⠀⠠⢭⣤⣭⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢬⣹⢿⣿⡏⠀⠀⠀⠀⠀⠀⠐⡿⣿⣿⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠨⠍⠉⠀⠀⠀⠀⠀⠀⠀⠡⠔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠀⢠⡤⠀⢀⠀⣤⠄⢀⣠⣤⣄⠀⠀⠀⠀⢀⣤⣤⡀⠀⢀⣀⡄⠀⠤⣤⠀⠀⠀⠀⠀⠀
//⠀⠀⠀⠀⠀⠀⠀⠈⠉⠀⠀⠉⠉⠉⠁⠈⠉⠉⠉⠁⠀⠀⠀⠉⠉⠉⠁⠀⠉⠉⠉⠀⠀⠉⠉
// aaaaaaaahhh⠀⠀⠀⠀⠀
package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.util.ElapsedTime;

@TeleOp

public class DriveCode extends LinearOpMode {
    //speeds
    final int FLYSPEED_CLOSE = 1200;
    final int FLYSPEED_MED = 1560;
    final int FLYSPEED_FAR = 1920;
    final int SPEED_TOLERANCE = 200;
    //static final double turretSpeed = .5;
    int driveSpeed = 700;
    int boost = 0;
    double flyWheelSpeed;
    //outtake motors
    private DcMotorEx turret;
    private DcMotorEx flyWheelRight;
    private DcMotorEx flyWheelLeft;
    //intake
    private DcMotorEx intake;
    //servos
    private CRServo outZero;
    private CRServo outOne;
    //drivemotors
    private DcMotorEx driveMotorBL;
    private DcMotorEx driveMotorFL;
    private DcMotorEx driveMotorBR;
    private DcMotorEx driveMotorFR;
    
    double readMotor;

    @Override
    public void runOpMode() {
        
        intake = hardwareMap.get(DcMotorEx.class, "intake");
        outZero = hardwareMap.get(CRServo.class, "out0");
        outOne = hardwareMap.get(CRServo.class, "out1");
        flyWheelRight = hardwareMap.get(DcMotorEx.class, "fly1");
        flyWheelLeft = hardwareMap.get(DcMotorEx.class, "fly2");
        turret = hardwareMap.get(DcMotorEx.class, "turret");
        driveMotorBL = hardwareMap.get(DcMotorEx.class, "driveBL");
        driveMotorFL = hardwareMap.get(DcMotorEx.class, "driveFL");
        driveMotorBR = hardwareMap.get(DcMotorEx.class, "driveBR");
        driveMotorFR = hardwareMap.get(DcMotorEx.class, "driveFR");
        
        telemetry.addData("Status", "Initialized");
        telemetry.update();
        
        driveMotorBL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        driveMotorBR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        driveMotorFL.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        driveMotorFR.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        
        turret.setTargetPosition(0);
        turret.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        turret.setVelocity(500);
        
        waitForStart();
        
        while (opModeIsActive()) {
            
            double oneRightStickX = - gamepad1.right_stick_x;
            double oneRightStickY = gamepad1.right_stick_y;
            double oneLeftStickX = gamepad1.left_stick_x;
            double oneLeftStickY = gamepad1.left_stick_y;
            double twoLeftStickY = gamepad2.left_stick_y;
            double twoRightStickX = gamepad2.right_stick_x;
            
            readMotor = flyWheelRight.getVelocity();
            //boost
            if (gamepad1.right_trigger > 0.1) {
                boost = 400;    
            } else if (gamepad1.left_trigger > 0.1) {
                boost = -400;    
            } else {
                boost = 0;
            }
            //drive
            driveMotorBL.setVelocity((driveSpeed + boost) * (oneLeftStickX + oneLeftStickY + oneRightStickX));
            driveMotorFL.setVelocity((driveSpeed + boost) * (-oneLeftStickX + oneLeftStickY + oneRightStickX));
            driveMotorBR.setVelocity((driveSpeed + boost) * (oneLeftStickX - oneLeftStickY + oneRightStickX));
            driveMotorFR.setVelocity((driveSpeed + boost) * (-oneLeftStickX - oneLeftStickY + oneRightStickX));
            //flywheel
            if (gamepad2.y){
                flyWheelSpeed = FLYSPEED_FAR;
            } else if (gamepad2.a){
                flyWheelSpeed = FLYSPEED_CLOSE;
            } else {
                flyWheelSpeed = FLYSPEED_MED;
            }
            
            if (gamepad2.right_bumper){
                flyWheelSpin(flyWheelSpeed, -1);
            } else {
                flyWheelSpin(flyWheelSpeed, 1);
            }
            //turret
            //turret.setPower(twoRightStickX * turretSpeed);
            //intake
            if (gamepad2.left_trigger > 0) {
                intake.setPower(-1);
            } else if (gamepad2.left_bumper){
                intake.setPower(1);
            } else {
                intake.setPower(0);
            }
            //servos
            if (gamepad2.dpad_up) {
                outZero.setPower(-1);
                outOne.setPower(1);
            } else if (gamepad2.dpad_down) {
                outZero.setPower(1);
                outOne.setPower(-1);
            } else {
                outZero.setPower(0);
                outOne.setPower(0);
            }

            telemetry.addData("motor flywheel vel:", readMotor);
            telemetry.addData("target speed", readMotor);
            telemetry.update();
        }
    }

    private void flyWheelSpin(int speed, int direction){
        //direction is 1 or -1
        if (readMotor < speed - 200){
            flyWheelLeft.setPower(direction);
            flyWheelRight.setPower(-direction);
        } else if (readMotor > speed + 200){
            flyWheelLeft.setPower(direction * .5);
            flyWheelRight.setPower(-direction * .5);
        }
    }
}